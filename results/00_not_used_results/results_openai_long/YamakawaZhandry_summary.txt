## High-level summary

This paper shows that **a uniformly random oracle (i.e., a “structureless” hash function)** is already enough to obtain **provable, publicly verifiable quantum advantage** for *NP search* problems and to separate classical vs. quantum security for several cryptographic primitives—**without relying on algebraic structure** (like period-finding) or number-theoretic assumptions (like factoring/LWE), except where explicitly noted.

A central theme is that while random-oracle quantum speedups for **decision problems** may be ruled out by the Aaronson–Ambainis conjecture, the authors show that **search problems** can still exhibit **unconditional super-polynomial quantum advantage** relative to a random oracle.

---

## Main results (relative to a random oracle, unless stated)

1. **NP search quantum advantage**
   - They construct an **NP search problem** that is solvable by **quantum polynomial time (QPT)** but not by any **classical PPT** (in fact, not even by computationally unbounded classical algorithms making only polynomially many oracle queries).
   - This gives a strong oracle-world separation: **BQP vs. BPP for NP search**.

2. **Publicly verifiable proofs of quantumness with minimal interaction**
   - They build **unconditional publicly verifiable proofs of quantumness**:
     - **Non-interactive** against **uniform** classical adversaries (since non-uniform adversaries could hardcode a proof).
     - **Two-message public-coin** against **non-uniform** classical adversaries (essentially optimal).
   - This contrasts prior publicly verifiable proofs of quantumness, which required *structured* oracles or strong assumptions.

3. **Cryptographic counterexamples (classically secure, quantum insecure)**
   They exhibit functions/primitives that look secure against classical attackers but are easy for quantum attackers:
   - **One-way functions** that are one-way against classical query-bounded adversaries but are **easy to invert quantumly**.
   - Even a **compressing collision-resistant hash function** (CRHF) in the classical ROM that becomes **not even one-way** against quantum adversaries.
   - Using prior generic transformations ([YZ21]), they obtain analogous separations for:
     - **Digital signatures**: classically EUF-CMA secure but quantumly breakable.
     - **Public-key encryption**: classically IND-CCA secure but quantumly not even IND-CPA (this one additionally assumes the existence of a classically IND-CPA PKE scheme).

   They note an interesting caveat: the separation **does not automatically extend to PRGs**; PRG security seems more tied to decision-type distinguishers and may be “harder to separate.”

4. **Certifiable randomness (assuming Aaronson–Ambainis)**
   - Their proofs of quantumness do not contradict the Aaronson–Ambainis conjecture because they rely on **sampling/search**, not decision.
   - Assuming the Aaronson–Ambainis conjecture, they construct **minimal-round certifiable randomness** protocols:
     - One message (uniform adversaries) / two messages (non-uniform adversaries), with public verifiability achievable by adding a final verifier message that can be published after receiving the prover’s message.

5. **Plausible “Minicrypt” instantiation via real hash functions**
   - Replacing the random oracle with a standard hash like **SHA-2** yields **plausible real-world candidates** for:
     - publicly verifiable proofs of quantumness,
     - NP search quantum advantage,
     - classically-secure-but-quantum-insecure primitives,
     - (and, conjecturally) certifiable randomness.
   - This is positioned as **a “Minicrypt-style” route to quantum advantage**, unlike prior approaches requiring public-key-like structure.

---

## Core technical idea (what they build)

They define a function based on an **error-correcting code** \(C \subseteq \Sigma^n\) over a huge alphabet \(\Sigma\), and a random oracle \(O:\Sigma\to\{0,1\}\). Define:

\[
f_C^O(c_1,\dots,c_n) = (O(c_1),\dots,O(c_n)) \in \{0,1\}^n \quad \text{for codewords } (c_1,\dots,c_n)\in C.
\]

Key properties with a carefully chosen code (folded Reed–Solomon with list-recovery + dual decodability):

- **Classical hardness:** Even an unbounded classical adversary making only polynomially many oracle queries can’t find a codeword mapping to a target \(y\) (e.g., \(0^n\)), except with negligible probability. This relies on **information-theoretic list-recoverability**: polynomially many oracle queries only “cover” polynomial candidate sets per position, which correspond to few codewords.
- **Quantum easiness:** There is a quantum procedure that (given \(y\)) can prepare a state close to a **uniform superposition over all preimages** of \(y\), using:
  - QFT over finite fields,
  - the dual code \(C^\perp\),
  - a decoding routine for noisy codewords,
  - and careful handling of small decoding-error amplitudes so they don’t blow up.

This function simultaneously underpins:
- the proof of quantumness (produce a valid preimage for a challenge like \(0^n\)),
- the NP-search separation,
- and the “classical one-way / quantum invertible” phenomena.

---

## Why this is notable

- Prior provable quantum speedups for NP-type tasks were tied to **structured problems** (periodicity, algebraic groups) or assumptions enabling public-key crypto.
- Random oracles are usually believed to be too “structureless” to enable **super-polynomial** quantum speedups for *verifiable* problems—especially in light of decision-problem simulation conjectures.
- This work shows that **search** changes the picture dramatically: even with a random oracle, you can get **publicly verifiable** quantum advantage.

---

If you tell me your preferred level (e.g., 1-page lay summary vs. technical summary with the main constructions/lemmas), I can tailor the summary accordingly.